#include<stdio.h>
#include<stdlib.h>
#define N 10
#define M 10
int main(){
	int m,n,a[N][M],maxj;
	printf("输入行数n："); 
	scanf("%d",&n);
	printf("输入列数m：");
	scanf("%d",&m);
	for(int i=0;i<n;i++){
		for(int j=0;j<m;j++){
			scanf("%d",&a[i][j]);
		}
	}
	//以上为输入，都懂吧 
	int flag2=0;//用来判断 有无鞍点 的 标记，
	//我们先默认这个矩阵没有鞍点 （flag2=0） 
	for(int i=0;i<n;i++){//遍历每一行 （一行一行的找） 
		//用来判断这一行的最大值是不是也是一列的最小值 的 标记
		//意思就是说 用来判断这一行是否存在整个矩阵的鞍点 
		//我们先默认 这一行的是存在整个矩阵的鞍点的（flag=1） 
		int flag = 1;
		
		int max=a[i][0];//初始假定这一行的第一个值是整行的最大值 
		maxj=0; //同时记录一下这个max所处的列 
		for(int j=0;j<m;j++){ 
		//遍历每一列 （开始把max和这一行的第2、3、4。。。个元素比较） 
			if(a[i][j]>max){//如果有元素比max大 
				max=a[i][j];//就把max换成这个元素的值 
				maxj=j;//同时 把列也换成该元素的 列 
			}
		}
		//经过上面一趟比较，就已经确定出了该行（第i行）的最大元素max
		//和对应的列 
		//下面开始判断这个元素是不是同时也是所属列的最小值（判断是不是鞍点） 
		for(int k=0;k<n;k++){//遍历每一行 
			if(max>a[k][maxj]){
			//只要这一列出现了比这个max小的元素，那么它 就一定不是鞍点 
				flag=0;//把标记置零 
				break;//不需要再循环下去了 ，因为这个max肯定不是鞍点 
			}
		}
		//如果上面一趟比较完了，flag没被置零（flag=1），
		//那么就是我们想要的鞍点了！！ 
		if(flag==1){ //如果flag没变（因为我们默认是1存在鞍点） 
			//只要存在一个鞍点，那么就不需要打印（矩阵无鞍点！）的信息了 
			//所以我们把flag2置为1（因为我们默认它是没鞍点的） 
			flag2=1;
			//输出信息 
			printf("第 %d 行 %d 列的 %d 是鞍点\n",i,maxj,max);
			//break;如果只要一个鞍点，那就break就行 
		}
	}
	//如果我们的flag2一直都是0（默认无鞍点），那么就输出无鞍点信息 
	if(flag2==0) printf("\n矩阵无鞍点!\n");
	return 0;
}
